diff --git a/src/platforms/stlink/platform.h b/src/platforms/stlink/platform.h
index 0ac91bb..78c81ce 100644
--- a/src/platforms/stlink/platform.h
+++ b/src/platforms/stlink/platform.h
@@ -71,6 +71,7 @@
 #define PLATFORM_HAS_TRACESWO	1
 #define NUM_TRACE_PACKETS		(128)		/* This is an 8K buffer */
 #define TRACESWO_PROTOCOL		2			/* 1 = Manchester, 2 = NRZ / async */
+#define TRACESWO_DECODE
 
 # define SWD_CR   GPIO_CRH(SWDIO_PORT)
 # define SWD_CR_MULT (1 << ((14 - 8) << 2))
diff --git a/src/platforms/stm32/traceswoasync.c b/src/platforms/stm32/traceswoasync.c
index 94b07c3..fc0391b 100644
--- a/src/platforms/stm32/traceswoasync.c
+++ b/src/platforms/stm32/traceswoasync.c
@@ -50,6 +50,12 @@ static volatile uint32_t r;	/* Packet currently waiting to transmit to USB */
 static uint8_t trace_rx_buf[NUM_TRACE_PACKETS * FULL_SWO_PACKET];
 /* Packet pingpong buffer used for receiving packets */
 static uint8_t pingpong_buf[2 * FULL_SWO_PACKET];
+#ifdef TRACESWO_DECODE
+/* buffer for decoded packets */
+static uint8_t swo_buf[CDCACM_PACKET_SIZE];
+static int swo_buf_len = 0;
+static int swo_pkt_len = 0;
+#endif
 
 void trace_buf_drain(usbd_device *dev, uint8_t ep)
 {
@@ -59,10 +65,37 @@ void trace_buf_drain(usbd_device *dev, uint8_t ep)
 	if (__atomic_test_and_set (&inBufDrain, __ATOMIC_RELAXED))
 		return;
 	/* Attempt to write everything we buffered */
+#ifdef TRACESWO_DECODE
+	/* decode swo packets and dump them on the uart port. typically reduces usb data by half compared to using an external tool */
+	(void) ep;
+	if (w != r) {
+		for (int i = 0; i<FULL_SWO_PACKET; i++) {
+			uint8_t ch=trace_rx_buf[r * FULL_SWO_PACKET + i];
+			if (swo_pkt_len == 0) { /* header */
+				if (ch == 0x01) swo_pkt_len = 1;      /* Write to ITM->PORT[0U].u8  SWO packet 0x01XX */
+				else if (ch == 0x02) swo_pkt_len = 2; /* Write to ITM->PORT[0U].u16 SWO packet 0x02XXXX */
+				else if (ch == 0x03) swo_pkt_len = 4; /* Write to ITM->PORT[0U].u32 SWO packet 0x03XXXXXXXX */
+			} else if (swo_pkt_len <= 4) { /* data */
+				swo_buf[swo_buf_len++]=ch;
+				if (swo_buf_len == CDCACM_PACKET_SIZE) {
+					if ((dev != NULL) && cdcacm_get_config() && cdcacm_get_dtr()) /* silently drop if usb not ready */
+						usbd_ep_write_packet(dev, CDCACM_UART_ENDPOINT, swo_buf, swo_buf_len);
+					swo_buf_len=0;
+				}
+				--swo_pkt_len;
+			} else { /* recover */
+				swo_buf_len=0;
+				swo_pkt_len=0;
+			}
+		}
+		r =(r + 1) % NUM_TRACE_PACKETS;
+	}
+#else
 	if ((w != r) && (usbd_ep_write_packet(dev, ep,
 										  &trace_rx_buf[r * FULL_SWO_PACKET],
 										  FULL_SWO_PACKET)))
 		r =(r + 1) % NUM_TRACE_PACKETS;
+#endif
 	__atomic_clear (&inBufDrain, __ATOMIC_RELAXED);
 }
 
